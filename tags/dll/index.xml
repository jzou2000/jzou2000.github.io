<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dll on My Hugo</title>
    <link>/tags/dll/</link>
    <description>Recent content in dll on My Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Oct 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/dll/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Shared Object Miscelleous</title>
      <link>/core/c&#43;&#43;/debug/shared-object-debug/</link>
      <pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/debug/shared-object-debug/</guid>
      <description>It is well known that LD_LIBRARY_PATY is used to specified the search paths for shared objects (dynamically loaded libraries, equivalent to DLL on Windows). However there are other environment varaibles that are also useful.
LD_DEBUG Let&amp;rsquo;s say an application app will load some shared objects. Set LD_DEBUG=help shows the usage of this variable.
export LD_DEBUG=help $ app Valid options for the LD_DEBUG environment variable are: libs display library search paths reloc display relocation processing files display progress for input file symbols display symbol table processing bindings display information about symbol binding versions display version dependencies scopes display scope information all all previous options combined statistics display relocation statistics unused determined unused DSOs help display this help message and exit To direct the debugging output into a file instead of standard output a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</description>
    </item>
    <item>
      <title>Shared Object and soname</title>
      <link>/core/c&#43;&#43;/make/soname/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/make/soname/</guid>
      <description>Useful command objdump - display information from object files nm - list symbols from object files objdump option description -p,&amp;ndash;private-headers needed for showing SONAME, dependencies, etc -t,&amp;ndash;syms symbols -C,&amp;ndash;demangle demangle C++ names SONAME SONAME is the &amp;rsquo;logical&amp;rsquo; name of a shared object, which is saved in the target binary when it is linked with a .so file, i.e. the linker use libname.so to resolve -lname and write its soname in the target file.</description>
    </item>
    <item>
      <title>Building Your Own Plugin Framework</title>
      <link>/core/c&#43;&#43;/plugin-framework/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/plugin-framework/</guid>
      <description>source Dr.Dobb&amp;rsquo;s Building Your Own Plugin Framework
Building Your Own Plugin Framework: Part 1 By Gigi Sayfan, November 25, 2007
This article is the first in a series of articles that discuss the architecture, development, and deployment of a C/C++ cross-platform plugin framework. This first installment explores the terrain, surveys (briefly) several existing plugin/component libraries, delves into the binary compatibility problem, and presents some desirable properties of the solution.
Subsequent articles showcase an industrial strength plugin framework that you can use on Windows, Linux, Mac OS X, and easily port to other operating systems.</description>
    </item>
  </channel>
</rss>
