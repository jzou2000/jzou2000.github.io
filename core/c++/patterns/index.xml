<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patterns on My Hugo</title>
    <link>/core/c&#43;&#43;/patterns/</link>
    <description>Recent content in Patterns on My Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/core/c++/patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CRTP - Curiously Recurring Template Pattern</title>
      <link>/core/c&#43;&#43;/patterns/crtp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/patterns/crtp/</guid>
      <description>References:
Original artical by James O. Coplien Fluent {C++} Wiki </description>
    </item>
    <item>
      <title>Private Implementation</title>
      <link>/core/c&#43;&#43;/patterns/pimpl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/patterns/pimpl/</guid>
      <description>What is Pimpl Pitfalls Explicit destructor should be implemented in the source file where Pimpl is defined and implemented, otherwise the compiler fails to delete Pimpl object. For example // in file a.h class A { A(); ~A() {} private: class Pimpl; //Pimpl* u; std::unique_ptr&amp;lt;Pimpl&amp;gt; u; }; and class A::Pimpl { friend class A; Pimpl() ... // unless using unique_ptr, ~Pimpl should be public (or accessible by owner that deletes it) ~Pimpl() .</description>
    </item>
    <item>
      <title>Rule Of the Big Five</title>
      <link>/core/c&#43;&#43;/patterns/big-five/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/patterns/big-five/</guid>
      <description>C++ uses RAII to manage resources, as a general guide of safe design or implementation, if you implement any of these five members, you&amp;rsquo;d better (or you have to) implement all of them.
destructor copy constructor assignment operator move constructor move assignment operator The reason behind this rule is that the compiler offers default implementation if they are not explicitly defined. The default implementation is member-wise-copy (for copy/assignment) or nothing (for destructor), which is usually NOT what you want if you have reason to define one of them.</description>
    </item>
    <item>
      <title>trait</title>
      <link>/core/c&#43;&#43;/patterns/trait/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/core/c&#43;&#43;/patterns/trait/</guid>
      <description>why trait sample implementation variable or function </description>
    </item>
  </channel>
</rss>
